---
title: '深入浅出事件循环'
description: '我印象里的 JavaScript，总是一副破破烂烂的样子。有时候乱七八糟的项目，却刚刚好能够跑起来，不会出什么问题。
它又没有很多功能，必须要借助外部的 API 才能满足正常的需求。
打个比方来说，好比一个跛脚的年轻人，看着也好，就是跑起来不太方便，需要多借助一些外物。
为了帮助他能够跑得更好，浏览器给它装了外骨骼，让它能快速奔跑，甚至有时超乎常人。
这里说到的外骨骼，就是前端开发者必须理解的一个概念——`事件循环`。'
pubDate: '2024-07-02'
tags: ['前端', 'JavaScript', '浏览器']
---

我印象里的 JavaScript，总是一副破破烂烂的样子。有时候乱七八糟的项目，却刚刚好能够跑起来，不会出什么问题。
它又没有很多功能，必须要借助外部的 API 才能满足正常的需求。
打个比方来说，好比一个跛脚的年轻人，看着也好，就是跑起来不太方便，需要多借助一些外物。
为了帮助他能够跑得更好，浏览器给它装了外骨骼，让它能快速奔跑，甚至有时超乎常人。
这里说到的外骨骼，就是前端开发者必须理解的一个概念—— `事件循环`。

## 前置知识

对以下知识有一定了解会更方便理解本文中提及的内容：

* JavaScript
* 浏览器的进程和线程架构
* 队列

## 解构事件循环

### 单线程的 JavaScript

JavaScript 是单线程的。或者说，这个方言的原规范，ECMAScript 的规范中，本身就没有 `线程` 这一概念。

但用过 JavaScript 的开发者，都知道 JavaScript 能够执行 `异步任务`。这导致很多初学者直觉上认为，JavaScript 自身是具备 `异步` 的能力的。

事实恰恰与直觉相反，JavaScript 能够执行 `异步任务`，并非其自身的因素，而在于其运行时提供的数个模块和机制。对于网页来说，那便是浏览器，
对于 Node.js 服务来说，那就是 libuv，这些外部的因素提供队列和 API，同时借助一个基于事件驱动的机制——`事件循环`，实现了 JavaScript 的 `异步` 和 `多线程` 工作。
甚至，在 Node.js 中，我们可以使用 JavaScript 去操作多进程。

打个比方，JavaScript 可能是的方向盘和操作杆，到底在什么交通工具上，是面包车、超跑还是飞机，决定了最终有什么能力。

### 事件循环概述

`事件循环` 是存在于大多数 JavaScript 运行环境中的一套机制，以协调事件、用户交互、脚本、渲染、网络等等。
用户代理必须遵循 [Web 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中的 `事件循环` 描述。

在现代浏览器中，就存在 `window 事件循环`、`worker 事件循环`、`worklet 事件循环` 数种事件循环。
我们常去描述的事件循环，指的是其中的 `window 事件循环`。本文主要讨论的也是此事件循环。此外，在 Node.js 中，也自有一套[事件循环机制](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#what-is-the-event-loop)。


`事件循环` 之所以称之为“循环”，是因为其内部实现类似于这样的机制（忽略细节）：
```js
while(true) {
  const chosenTaskQueue = chooseATaskQueue();
  const task = chooseRunnableTask(chosenTaskQueue);
  run(task);
  // 做其他事
  let microTask = null;
  while (microTask =  dequeueMicroTask()) {
    run(microTask);
  }
  // 做其他事
}
```
这个循环通常是运行在单独的线程上的，而 JavaScript 的宿主环境往往是 `多线程` 的，因此不会造成应用的阻塞。


### 任务和微任务的概念

`事件循环` 中的各种机制和 `任务` 这个概念相关。在浏览器的事件循环中，[`任务（Task）`](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task) 特指一类特殊的数据结构，其声明了步骤、任务源、关联文档、脚本求值的环境设定对象集合等。

一个相关联的概念是 [`微任务`](https://html.spec.whatwg.org/multipage/webappapis.html#microtask)，这是为区分通过 [`微任务入队`](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask) 算法和 [`任务入队`](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask) 算法生成的任务的，针对于前者的特称。一般地，谈论事件循环中的 `任务`，需要根据上下文语境判断，偶尔会代指狭义上的区别于 `微任务` 的任务。

我们常常把 `微任务` 以外的 `任务` 称为 `宏任务`，以明显区分二者，由此自然而然地，这些 `任务` 所在的 `任务队列` 就成为了 `宏任务队列`。但由于规范中未指定该种 `Task` 的称呼，对应的英文可能是 `MacroTask`，也仅在网络论坛中出现，同时，鉴于中英文语境下“宏”不体现任何此类任务的特性，且容易造成理解上的问题（如，理解为使用宏的任务），因此，本文仍然使用 `任务` 作为指代。

### 事件循环中的队列

浏览器的 `事件循环` 中有多种 `“队列”` 参与，但它们在总体上可以划分为两种，一种是 `任务队列`，另一种是 `微任务队列`。

[`任务队列`](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue) 是存放 `任务` 的集合（Set），[`微任务队列`](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue) 是存放 `微任务` 的队列（Queue）。
之所以称呼前者为集合，是因为其数据结构行为上表现不同于队列的定义，事件循环的处理模型从中**选择可运行的任务**，而非令队头元素出队。
因此，微任务队列不是任务队列，也不是任务队列的子集。有时候，术语的定义有很大程度的历史原因，也会发生这种集合不是集合，叫做队列的情况。

一个**事件循环**可以有一或多个**任务队列**，但 `微任务队列` 只能有一个。每个 `任务` 通过 `源（source）` 字段指定其来自一个特定的 `任务源（Task Source）`，借助此字段，其与特定的 `任务队列` 相关联，相对地，`任务队列` 通过此字段对其相关联的 `任务` 进行分组和序列化。

无论浏览器实现如何，规范中定义了一些 [`通用任务源（Generic Task Source）`](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)：
* **DOM 操作任务源（the DOM Manipulation Task Source）**：此任务源用于响应 DOM 操作的特性，比如，元素插入到文档时以非阻塞方式发生某事。
* **用户交互任务源（the User Interaction Task Source）**：此任务用于响应用户输入的特性，比如，键盘和鼠标输入。响应用户输入（像是 `click` 事件）而发送的事件（Event）必须使用用户交互任务源为参数的任务入队算法。
* **网络任务源（the Networking Task Source)`：此任务源用于响应网络活动而触发的特性。
* **导航和遍历任务源（the Navigation and Traversal Task Source）**：此任务源用于入队导航和历史遍历中涉及的任务。
* **渲染任务源（the Rendering Task Source）**：此任务源单独用于更新渲染。

因此，一般地讲，现代浏览器中将包含这五种 `通用任务源` 对应的 `任务队列`，同时还有一个`微任务队列`。
浏览器如何处理这些 `“队列”`，和 `任务`，将会在稍后的章节叙述。

### 事件循环处理模型

要想摸清事件处理到底如何工作的，浏览器的
我们可以对照 WHATWG 规范中的[处理模型](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)一章，理解整个事件循环核心的工作机制。如果忽略细节继续整体上理解，可以跳过此小节。

以下是此章节的翻译，以方便对照。

#### 规范翻译

事件循环必须通过以下步骤持续运行，只要当其仍然存在：
1. 声明 <var>oldestTask</var> 和 <var>taskStartTime</var> 为 null。
2. 如果**事件循环**存在至少有一个**可运行任务**的**任务队列**，那么：
    1. 声明 <var>taskQueue</var> 为所述任务队列之一，以[实现定义](https://infra.spec.whatwg.org/#implementation-defined)的风格进行选择。
    注意：记住，[微任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue)不是[任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue),因此它不会在此步骤中被选中。然而，与[微任务任务源](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-task-source)相关联的[任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)。在此场景下，在下一步骤中被选中的[任务](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)原本是[微任务](https://html.spec.whatwg.org/multipage/webappapis.html#microtask)，但作为[执行事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#spin-the-event-loop)的一部分被移动了。
    2. 赋值 <var>taskStartTime</var> 以不安全的共享的当前时间。
    3. 赋值 <var>oldestTask</var> 以 <var>taskQueue</var> 中第一个可运行任务，同时从 <var>taskQueue</var> 中移除。
    4. 如果 <var>oldestTask</var> 非 null，则给定 <var>taskStartTime</var> 和 <var>oldestTask</var> 以记录任务开始时间。
    5. 赋值事件循环的当前运行任务以 <var>oldestTask</var>。
    6. 执行 <var>oldestTask</var> 的步骤。
    7. 赋值事件循环的当前运行任务为 null，回到初始值。
    8. 执行一个微任务检查点。
3. 声明 <var>taskEndTime</var> 为不安全的共享的当前时间。[高精度时间]
4. 如果 <var>oldestTask</var> 非 null，则：
    1. 声明 <var>top-level browsing contexts</var> 为一个空集合。
    2. 对于 <var>oldestTask</var> 的脚本求值的环境设定对象集合中的每个环境设定对象 <var>settings</var>：
        1. 声明 <var>global</var> 为 <var>settings</var> 的全局对象。
        2. 如果 <var>global</var> 非 Window 对象，则继续。
        3. 如果 <var>global</var> 的[浏览上下文](https://html.spec.whatwg.org/multipage/nav-history-apis.html#window-bc)为 null，则继续。
        4. 声明 <var>tlbc</var> 为 <var>global</var> 的浏览上下文的[顶级浏览上下文](https://html.spec.whatwg.org/multipage/document-sequences.html#bc-tlbc)。
        5. 如果 <var>tlbc</var> 非 null，则将其添加到 <var>top-level browsing contexts</var>。
    3. [报告长任务](https://w3c.github.io/longtasks/#report-long-tasks)，传入 <var>taskStartTime</var>、<var>taskEndTime</var>、<var>top-level browsing contexts</var>、
    <var>oldestTask</var>。
    4. 如果 <var>oldestTask</var> 的 [document](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-document) 非 null，则给定 <var>taskEndTime</var> 和 <var>oldestTask</var> 以[记录任务结束时间](https://w3c.github.io/long-animation-frames/#record-task-end-time)。
5. 如果此事件循环是[window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop)，且其所有事件循环的任务队列中没有可运行任务，则：
    1. 赋值此事件循环的上个空闲周期开始时间以不安全的共享的当前时间。
    2. 声明 <var>computeDeadline</var> 为以下步骤：
        1. 声明 <var>deadline</var> 为此事件循环的上个空闲周期开始时间再加 50。
        注意：给定未来 50ms 的上限以确保在用户感知阈值内可以响应新的用户输入。
        2. 声明 <var>hasPendingRenders</var> 为 false。
        3. 对于此事件循环的[所有相同循环窗口](https://html.spec.whatwg.org/multipage/webappapis.html#same-loop-windows)中的每个 <var>windowInSameLoop</var>：
            1. 如果 <var>windowInSameLoop</var> 的[动画帧回调映射](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#list-of-animation-frame-callbacks)非空，或者，如果用户代理确信 <var>windowInSameLoop</var> 可能存在阻塞的渲染更新，那么赋值 <var>hasPendingRenders</var> 为 true。
            2. 声明 <var>timerCallbackEstimates</var> 为 <var>windowInSameLoop</var> 的[活动计时器映射](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#map-of-active-timers)进行[获取全部值](https://infra.spec.whatwg.org/#map-getting-the-values)的结果。
            3. 对于 <var>timerCallbackEstimates</var> 中的每个 <var>timeoutDeadline</var>，如果 <var>timeoutDeadline</var> 小于 <var>deadline</var>，赋值 <var>deadline</var> 以 <var>timeoutDeadline</var>。
        4. 如果 <var>hasPendingRenders</var> 为 true，则：
            1. 声明 nextRenderDeadline 为此事件循环中[上个渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)加上（1000除以当前刷新率）。
               刷新率可以是硬件上的或是特定于实现的。对于 60Hz 的刷新率，<var>nextRenderDeadline</var> 可能是[上次渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)后约 16.67ms.
            2. 如果 <var>nextRenderDeadline</var> 小于 <var>deadline</var>，则返回 <var>nextRenderDeadline</var>。
        5. 返回 <var>deadline</var>。
6. 如果此循环是[worker 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#worker-event-loop-2)，则：
    1. 如果此事件循环[代理](https://tc39.es/ecma262/#sec-agents)的单一[域（Realm）](https://tc39.es/ecma262/#sec-code-realms)的[全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-realm-global)是一个[被支持的](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#concept-animationframeprovider-supported) [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope)，且用户代理坚信代理自身将从执行其此次渲染更新中受益，则：
        1. 声明 <var>now</var> 为给定 [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope) 的[当前高精度时间](https://w3c.github.io/hr-time/#dfn-current-high-resolution-time)。[高精度时间]
        2. 执行该 [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope) 的所有动画帧回调，传入 <var>now</var> 作为时间戳。
        3. 更新该 Dedicated Worker 的渲染以反映当前的状态。
        注意：类似于在 [window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop)中[更新渲染](https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering)的注意事项（见上），用户代理可以决定 Dedicated Worker 渲染的速率。
    2. 如果该事件循环的所有任务队列都没有任务，且 [WorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope) 对象的[关闭](https://html.spec.whatwg.org/multipage/workers.html#dom-workerglobalscope-closing)标志为 true，则销毁事件循环，中止这些步骤，恢复后续 Web Worker 章节中描述的[运行 worker](https://html.spec.whatwg.org/multipage/workers.html#run-a-worker) 的步骤。

[window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop) <var>eventLoop</var> 也必须并行地运行下述步骤，只要当其仍然存在：
    1. 等待，直到至少有一个[“可通行”（特殊数据结构，这里作名词）](https://html.spec.whatwg.org/multipage/document-sequences.html#navigable) <var>navigable</var>，其[活动文档](https://html.spec.whatwg.org/multipage/document-sequences.html#nav-document)[相关代理](https://html.spec.whatwg.org/multipage/webappapis.html#relevant-agent)的事件循环是 <var>eventLoop</var> 可能具有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)。
    2. 赋值 <var>eventLoop</var> 的[上次渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)为不安全的共享的当前时间。
    3. 对于每个具有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)的 <var>navigable</var>，给定 <var>navigable</var> 的[活动窗口](https://html.spec.whatwg.org/multipage/document-sequences.html#nav-window)[以入队一个全局任务](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-global-task)，从而**更新渲染**。
    注意：这可能会导致出现重复调用以更新渲染。但是，因为它们作为必要渲染步骤，此时没有渲染的必要，所以这些调用不会造成可观测的影响。实现中可以引入进一步的优化，像是仅当此任务尚未入队时才将其入队。但是，要注意该任务在得到处理前，其关联的文档可能变为非活动状态。
        1. 声明 <var>frameTimestamp</var> 为 <var>eventLoop</var> 的上次渲染机会时间。
        2. 声明 <var>docs</var> 为所有[相关代理](https://html.spec.whatwg.org/multipage/webappapis.html#relevant-agent)的事件循环是 <var>eventLoop</var> 的[完全活动](https://html.spec.whatwg.org/multipage/document-sequences.html#fully-active) [文档对象](https://html.spec.whatwg.org/multipage/dom.html#document)，其任意排序但需要满足以下条件：
            * 任何[容器文档](https://html.spec.whatwg.org/multipage/document-sequences.html#doc-container-document)为 A 的[文档] B 在列表中必须排在 A 之后
            * 如果由两个文档 A 和 B，均存在相同非 null [容器文档](https://html.spec.whatwg.org/multipage/document-sequences.html#doc-container-document) C，则 A 和 B 在列表中的顺序必须满足它们在 C 的[节点树](https://dom.spec.whatwg.org/#concept-node-tree)中对应[可导航至容器](https://html.spec.whatwg.org/multipage/document-sequences.html#navigable-container)的[影子包含树顺序](https://dom.spec.whatwg.org/#concept-shadow-including-tree-order)。
        在下述迭代 <var>docs</var> 的步骤中，每个文档对象必须按照其在列表中发现的顺序被处理。
        3. 过滤不可渲染的文档：从 <var>docs</var> 中移除满足下列任意条件的所有文档对象 <var>doc</var>：
            * <var>doc</var> 是[渲染阻塞](https://html.spec.whatwg.org/multipage/dom.html#render-blocked)的；
            * <var>doc</var> 的[可见状态](https://html.spec.whatwg.org/multipage/interaction.html#visibility-state)为 “hidden”；
            * <var>doc</var> 的渲染[因视图转换被阻止](https://drafts.csswg.org/css-view-transitions/#document-rendering-suppression-for-view-transitions)；或
            * <var>doc</var> 的[节点的“可通行”](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable)当前没有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)。
        注意：在[以并行](https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel)步骤检查之外，我们还必须在这里检查[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)，因为一些共享相同[事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop)的文档可能不会同时具有渲染机会。
        4. 非必要渲染：从 <var>docs</var> 中移除满足下列所有条件的所有文档对象 <var>doc</var>：
            * 用户代理坚信更新 <var>doc</var> 节点的“可通行”的渲染不会有任何可见的影响；同时
            * <var>doc</var> [动画帧回调映射](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#list-of-animation-frame-callbacks)为空。
        5. 从 <var>docs</var> 中移除由于其他理由，用户代理坚信其适合跳过更新渲染的所有文档对象 <var>doc</var>。
        注意：
        此步骤标明了过滤不可渲染的文档阻止用户代理在无法向用户呈现新内容时更新渲染。
        此步骤标明了非必要渲染阻止用户代理在没有新内容需要绘制时阻止更新渲染。
        此步骤使用户代理能够因其他理由阻止下列步骤运行，例如，为确保某些[任务](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)在彼此之后能够立刻执行，仅交叉[微任务检查点](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)（且不交叉其他，如[动画帧回调](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks)）。具体来说，用户代理可能希望合并计时器回调到一起，而不立刻渲染更新。
        6. 对于每个 <var>docs</var> 中的 <var>doc</var>，[显示](https://html.spec.whatwg.org/multipage/browsing-the-web.html#reveal) <var>doc</var>。
        7. 对于每个 <var>docs</var> 中的 <var>doc</var>，如果其[节点的“可通行”](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable)是一个[顶级的“可遍历”](https://html.spec.whatwg.org/multipage/document-sequences.html#top-level-traversable)（特殊的数据结构，原文中形作名），为其[刷新自动聚焦候选](https://html.spec.whatwg.org/multipage/interaction.html#flush-autofocus-candidates)。
        8. 对于每个 <var>docs</var> 中的 <var>doc</var>，运行[调整尺寸步骤](https://drafts.csswg.org/cssom-view/#document-run-the-resize-steps)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        9. 对于每个 <var>docs</var> 中的 <var>doc</var>，运行[滚动步骤](https://drafts.csswg.org/cssom-view/#document-run-the-scroll-steps)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        10. 对于每个 <var>docs</var> 中的 <var>doc</var>，为 <var>doc</var> [求值媒体查询并报告改变](https://drafts.csswg.org/cssom-view/#evaluate-media-queries-and-report-changes)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        11. 对于每个 <var>docs</var> 中的 <var>doc</var>，为 <var>doc</var> [更新动画并发送事件](https://drafts.csswg.org/web-animations-1/#update-animations-and-send-events)，给定 <var>frameTimestampe</var> 和 <var>doc</var> 的[相关全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-relevant-global)作为时间戳，以[传入相对高精度时间](relative high resolution time)。[WEBANIMATIONS](https://html.spec.whatwg.org/multipage/references.html#refsWEBANIMATIONS)
        12. 对于每个 <var>docs</var> 中的 <var>doc</var>，为 <var>doc</var> [运行全屏步骤](https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps)。
        13. 对于每个 <var>docs</var> 中的 <var>doc</var>，如果用户代理检测到与任一 [CanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#canvasrenderingcontext2d) 或 [OffscreenCanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#offscreencanvasrenderingcontext2d)—— <var>context</var> ——相关联的后备存储已经丢失，则用户代理必须为每个类似的 <var>context</var> 运行**上下文丢失步骤**：
            1. 声明 <var>canvas</var> 为 <var>context</var> 的 [canvas](https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-canvas) 属性，如果上下文是一个  [CanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#canvasrenderingcontext2d)，否则，声明其为 [<var>context</var> 相关的](https://html.spec.whatwg.org/multipage/canvas.html#associated-offscreencanvas-object) OffscreenCanvas 对象。
            2. 赋值 <var>context</var> 的[上下文丢失](https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-context-lost)为 true。
            3. 给定 <var>context</var> 以[重置渲染上下文到其默认状态](https://html.spec.whatwg.org/multipage/canvas.html#reset-the-rendering-context-to-its-default-state)。
            4. 声明 <var>shouldRestore</var> 为于 <var>canvas</var> 上[发送](https://dom.spec.whatwg.org/#concept-event-fire)一个名为 [contextlost](https://html.spec.whatwg.org/multipage/indices.html#event-contextlost) 的事件的结果，该事件的 [cancelable](https://dom.spec.whatwg.org/#dom-event-cancelable) 属性被初始化为 true。
            5. 如果 <var>shouldRestore</var> 为 false，则中止这些步骤。
            6. 尝试通过使用 <var>context</var> 的属性创建后备存储并将它们与 var{context} 相关联的方法，来恢复 <var>context</var>。如果此方法失败，则中止这些步骤。
            7. 赋值 <var>context</var> 的上下文丢失为 false。
            8. 于 <var>canvas</var> 上[发送](https://dom.spec.whatwg.org/#concept-event-fire)一个名为 [contextrestored](https://html.spec.whatwg.org/multipage/indices.html#event-contextrestored) 的事件。
        14.


<table class='text-left'>
  <caption>部分翻译对照表</caption>
  <thead>
    <th>原文</th>
    <th>翻译</th>
    <th>备注</th>
  </thead>
  <tbody>
  <tr>
    <td>let ... be</td>
    <td>声明……为</td>
    <td>声明……并赋值</td>
  </tr>
  <tr>
    <td>set ... to</td>
    <td>赋值……以</td>
  </tr>
  <tr>
    <td>if ... then</td>
    <td>如果……则</td>
  </tr>
  <tr>
    <td>is ...</td>
    <td>为...</td>
  </tr>
  <tr>
    <td>is <var>variable</var></td>
    <td>是 <var>variable</var></td>
    <td>等效于浅比较上相等，是同一值</td>
  </tr>
  <tr>
    <td>is not...</td>
    <td>非...</td>
  </tr>
   <tr>
    <td>do sth. given ...</td>
    <td>给定……以做某事</td>
    <td>给定参数执行算法</td>
  </tr>
  <tr>
    <td>perform ...</td>
    <td>执行……</td>
  </tr>
  <tr>
    <td>resume</td>
    <td>恢复</td>
  </tr>
  <tr>
    <td>continue</td>
    <td>继续</td>
    <td>继续算法步骤</td>
  </tr>
  <tr>
    <td>current</td>
    <td>当前</td>
  </tr>
  <tr>
    <td>destroy</td>
    <td>销毁</td>
  </tr>
  <tr>
    <td>abort</td>
    <td>中止</td>
  </tr>
  <tr>
    <td>detect</td>
    <td>检测到</td>
  </tr>
  <tr>
    <td>this/that/the</td>
    <td>此</td>
  </tr>
   <tr>
    <td>spin the event loop</td>
    <td>执行事件循环</td>
    <td>spin 指高速旋转，此处意译</td>
  </tr>
  <tr>
    <td>environment settings object</td>
    <td>环境设置对象</td>
  </tr>
  <tr>
    <td>script evaluation</td>
    <td>脚本求值</td>
  </tr>
  <tr>
    <td>append</td>
    <td>添加</td>
  </tr>
  <tr>
    <td>set</td>
    <td>集合</td>
  </tr>
  <tr>
    <td>map</td>
    <td>映射</td>
  </tr>
  <tr>
    <td>list</td>
    <td>列表</td>
  </tr>
  <tr>
    <td>resize</td>
    <td>调整尺寸</td>
  </tr>
  <tr>
    <td>scroll</td>
    <td>滚动</td>
  </tr>
  <tr>
    <td>animation frame callback(s)</td>
    <td>动画帧回调</td>
  </tr>
  <tr>
    <td>timer callback(s)</td>
    <td>计时器回调</td>
  </tr>
  <tr>
    <td>pending</td>
    <td>阻塞</td>
  </tr>
  <tr>
    <td>active</td>
    <td>活动</td>
    <td>活动有活跃之意，由惯例使用前者</td>
  </tr>
  <tr>
    <td>microtask checkpoint(s)</td>
    <td>微任务检查点</td>
  </tr>
  <tr>
    <td>map of animation frame callbacks</td>
    <td>动画帧回调映射</td>
  </tr>
    <tr>
    <td>active window</td>
    <td>活动窗口</td>
    <td>活动</td>
  </tr>
  <tr>
    <td>map of active timers</td>
    <td>活动计时器映射</td>
  </tr>
  <tr>
    <td>update the rendering</td>
    <td>更新渲染</td>
  </tr>
  <tr>
    <td>last render opportunity time</td>
    <td>上个渲染机会</td>
  </tr>
  <tr>
    <td>... document</td>
    <td>……文档</td>
    <td>属于某数据结构的文档，<br/>文中代指 Document 或 null</td>
  </tr>
   <tr>
    <td>Document (object)</td>
    <td>文档(对象)</td>
    <td>均代指某一类特殊数据结构</td>
  </tr>
  <tr>
    <td>navigable</td>
    <td>“可通行”</td>
    <td>指一类数据结构，形容词作名词</td>
  </tr>
   <tr>
    <td>node navigable</td>
    <td>节点的“可通行”</td>
    <td>指一类数据结构，形容词作名词</td>
  </tr>
  <tr>
    <td>top-level traversable</td>
    <td>顶级的“可遍历”</td>
    <td>指一类数据结构，形容词作名词</td>
  </tr>
  <tr>
    <td>shadow-including tree order</td>
    <td>影子包含树顺序</td>
  </tr>
  <tr>
    <td>render-blocked</td>
    <td>渲染阻塞的</td>
  </tr>
  <tr>
    <td>visibility state</td>
    <td>可见状态</td>
  </tr>
  <tr>
    <td>view transition(s)</td>
    <td>视图转换</td>
  </tr>
  <tr>
    <td>the backing storage</td>
    <td>后备存储</td>
  </tr>
  <tr>
    <td>context</td>
    <td>上下文</td>
  </tr>
  <tr>
    <td>attribute</td>
    <td>属性</td>
  </tr>
  <tr>
    <td>restore</td>
    <td>恢复</td>
  </tr>
  </tbody>
</table>

## 事件循环？何时来的？


## 揭露真实的事件循环


## 其他环境中的事件循环


## 事件驱动和状态驱动

## 碎碎念

## 参考文献
[1]: WHATWG. HTML Living Standard[DB/OL]. [参考链接](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops). 2024-07-02
