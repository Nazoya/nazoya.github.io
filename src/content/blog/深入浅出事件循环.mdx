---
title: '深入浅出事件循环'
description: '我印象里的 JavaScript，总是一副破破烂烂的样子。有时候乱七八糟的项目，却刚刚好能够跑起来，不会出什么问题。
它又没有很多功能，必须要借助外部的 API 才能满足正常的需求。
打个比方来说，好比一个跛脚的年轻人，看着也好，就是跑起来不太方便，需要多借助一些外物。
为了帮助他能够跑得更好，浏览器给它装了外骨骼，可以接入各种拓展，让它能快速奔跑，甚至有时超乎常人。
这里说到的外骨骼，就是前端开发者必须理解的一个概念——事件循环。'
pubDate: '2024-07-02'
tags: ['前端', 'JavaScript', '浏览器']
---
import { Picture } from 'astro:assets';
import imageEattingBuffet from '@/assets/images/吃自助餐.png';
import imageEventLoopModules from '@/assets/images/事件循环分界图.png';
import imageBenchmarkTest from '@/assets/images/DocumentFragment-测试.png';

我印象里的 JavaScript，总是一副破破烂烂的样子。有时候乱七八糟的项目，却刚刚好能够跑起来，不会出什么问题。
它又没有很多功能，必须要借助外部的 API 才能满足正常的需求。
打个比方来说，好比一个跛脚的年轻人，看着也好，就是跑起来不太方便，需要多借助一些外物。
为了帮助他能够跑得更好，浏览器给它装了外骨骼，可以接入各种拓展，让它能快速奔跑，甚至有时超乎常人。
这里说到的外骨骼，就是前端开发者必须理解的一个概念——**事件循环**。

## 前置知识

对以下知识有一定了解会更方便理解本文中提及的内容：

* JavaScript
* 浏览器的进程和线程架构
* 队列

## 解构事件循环

### 进程和线程

在正式开始我们的主题之前，我们需要回顾一些涉及的知识，避免混淆。

**进程**是一个独立的运行单位，其是操作系统进行资源分配和调度的基本单位。

**线程**是为了更好支撑并发执行，提高资源利用率的基本 CPU 执行单元，也是程序执行流的最小单元。

线程是进程中的一个实体，是被系统独立调度和分派的基本单位，其自身不拥有系统资源，只拥有必须的允许资源，但可和其他同一进程中的线程**共享**该进程拥有的所有资源。

引入线程后，进程不再作为执行单元，而是线程取代了此职能，其特性使得不同线程在属于相同进程时切换上下文的成本较低。有一点重要的是，这样以线程为独立调度的基本单元的现代操作系统中，我们说一个进程运行，**其实是进程中的某一线程在运行**。

### 单线程的 JavaScript

JavaScript 是**单线程的**。或者说，在单线程上运行。这个方言的原规范，ECMAScript 规范中，本身就没有**线程**这一概念。

但用过 JavaScript 的开发者，都知道 JavaScript 能够执行**异步任务**。这导致很多初学者直觉上认为，JavaScript 自身就具备**异步**能力。

事实恰恰与直觉相反，JavaScript 能够执行**异步任务**，并非其自身的因素，而在于其运行时提供的数个模块和机制。对于网页来说，那便是浏览器，对于 Node.js 服务来说，那就是 libuv。这些外部的因素提供队列和 API，同时借助一个基于事件驱动的机制——**事件循环**，实现了 JavaScript 的**异步**和**多线程**工作。甚至，在 Node.js 中，我们可以使用 JavaScript 去操作多进程。

打个比方，JavaScript 可能是的方向盘和操作杆，到底在什么交通工具上，是面包车、超跑还是飞机，决定了最终有什么能力。

想象一下，有这样一个场景。自助餐厅里，摆放着许多盛满饭菜的硕大盘子，你是餐厅的一位顾客，每次吃完饭都要去取一点食物回来。为了尽可能划算地吃上一顿，如果有牛排，你可能优先拿一些牛排。后厨的师傅一直在烹饪，做完菜时会间歇地补充盘子上的食物，但也可能原材料耗尽，导致盘子最后一直是空的。餐厅也提供生食材，你可以自取做火锅和烤肉，但像是活螃蟹之类的，你只能带给师傅帮你现做，之后放到盘子里通知你来取。

这个场景里，你就是“JavaScript 引擎”，后厨的师傅就是外部环境——如浏览器，我们称这些盘子为“任务队列”或者“微任务队列”，你根据最划算方案从这些“队列”取食物回来消费的步骤称为“事件循环”，你有一定的烹饪能力，但不够强大，但你可以让师傅帮你烹饪，在浏览器环境下这就是调用 Web API，这一步骤的产出最后还会回到专门的“队列”中等你取走消费——这就是 JavaScript 的异步。

<figure class='text-center'>
  <Picture src={imageEattingBuffet} formats={['avif', 'webp']} alt='吃自助餐' class='mx-auto max-h-72 w-auto'  />
  <figcaption>吃自助餐</figcaption>
</figure>

这个场景可能不完全正确，但应该有助于对事件循环的整体认识。整个事件循环实际是一种巧妙的**生产者-消费者模式**，在操作系统进程共享和常见的消息队列系统（RabbitMQ、Kafka 等）都有使用。

### 事件循环概述

**事件循环**是存在于大多数 JavaScript 运行环境中的一套机制，以协调事件、用户交互、脚本、渲染、网络等等。它**不是**JavaScript 自身的一部分。用户代理必须遵循[Web 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中的**事件循环**描述。

在现代浏览器中，就存在 **window 事件循环**、**worker 事件循环**、**worklet 事件循环**数种事件循环。我们常去描述的事件循环，指的是其中的**window 事件循环**。本文主要讨论的也是此事件循环。此外，在 Node.js 中，也自有一套[事件循环机制](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#what-is-the-event-loop)。

**事件循环**之所以称之为“循环”，是因为其内部实现类似于这样的机制（忽略细节）：
```js
while(true) {
  // 用算法选择一个可运行的任务，然后运行它
  const chosenTaskQueue = chooseATaskQueue();
  const task = chooseRunnableTask(chosenTaskQueue);
  run(task);
  // 做其他事
  // 然后处理所有微任务
  let microTask = null;
  while (microTask =  dequeueMicroTask()) {
    run(microTask);
  }
  // 做其他事
}
```
JavaScript 的宿主环境往往是**多线程**的，而一个事件循环仅会在一个线程上运行，因此不会造成应用的阻塞。规范并未限定每个事件循环必须有单独的实现线程，按具体情况，也可能出现一个线程多个事件循环。

从整体上看，我们可以将事件循环所在的系统按职责描述为以下几个部分：
* **JavaScript 引擎**，包含调用栈等，负责运行任务
* **事件循环**，选取任务指派给 JavaScript 引擎
* **任务队列和微任务队列**，其他模块用其存放任务以便与事件循环共享
* **Web API**，提供给 JavaScript 引擎异步回调、功能扩展和间接入队任务的能力
* **其他部分**，如计时器模块、UI 模块、网络模块等，可以在满足特定条件后让任务入队“队列”

<figure class='text-center'>
  <Picture src={imageEventLoopModules} width={755} height={503} formats={['avif', 'webp']} alt='事件循环分界图' class='mx-auto w-auto'  />
  <figcaption>事件循环分界图</figcaption>
</figure>

### 任务和微任务的概念

**事件循环**中的各种机制和**任务**这个概念相关。在浏览器的事件循环中，[任务（Task）](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)特指一类特殊的数据结构，其声明了**步骤**、任务源、关联文档、脚本求值（Script Evaluation）的环境设定对象集合等。

一个相关联的概念是[**微任务**](https://html.spec.whatwg.org/multipage/webappapis.html#microtask)，这是为区分通过[微任务入队](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-microtask)算法生成的任务和其他任务入队算法生成的任务而提出的称呼。微任务是任务的一种，微任务的全体是任务全体的真子集。

我们常常把**微任务**以外的任务称为**宏任务**，以明显区分二者，由此自然而然地，这些任务所在的**任务队列**就成为了**宏任务队列**。但由于规范中未指定该种任务的称呼，对应的英文**可能**是 **MacroTask**，也仅在网络论坛中出现，同时，鉴于中英文语境下“宏”不体现任何此类任务的特性，且容易造成理解上的问题（如，理解为使用宏的任务），因此，本文仍然使用**任务**作为指代。

### 事件循环中的队列

浏览器的事件循环中有多种“**队列**”参与，但它们在总体上可以划分为两种，一种是**任务队列**，另一种是**微任务队列**。

[**任务队列**](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)是存放任务的**集合（Set）**，[**微任务队列**](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue)是存放微任务的**队列（Queue）**。
之所以称呼前者为集合，是因为其行为上表现不同于队列的定义，事件循环的处理模型从中**选择可运行的任务**，而**非**令队头元素出队。
因此，微任务队列**不是**任务队列，也不是任务队列的子集。有时候，术语的定义有很大程度的历史原因，也会发生这种集合不是集合，叫做队列的情况。

一个事件循环可以有**一或多个**任务队列，但**微任务队列**只能有一个。每个**任务**通过源 source 字段指定其来自一个特定的**任务源（Task Source）**，借助此字段，其与特定的任务队列相关联，相对地，任务队列通过此字段对其相关联的任务进行分组和序列化。

无论浏览器实现如何，规范中定义了一些[**通用任务源（Generic Task Source）**](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)：
* **DOM 操作任务源（the DOM Manipulation Task Source）**：此任务源用于响应 DOM 操作的特性，比如，元素插入到文档时以非阻塞方式发生某事。
* **用户交互任务源（the User Interaction Task Source）**：此任务用于响应用户输入的特性，比如，键盘和鼠标输入。响应用户输入（像是 **click** 事件）而发送的事件（Event）必须使用用户交互任务源为参数的任务入队算法。
* **网络任务源（the Networking Task Source)`：此任务源用于响应网络活动而触发的特性。
* **导航和遍历任务源（the Navigation and Traversal Task Source）**：此任务源用于入队导航和历史遍历中涉及的任务。
* **渲染任务源（the Rendering Task Source）**：此任务源单独用于更新渲染。

因此，一般地讲，现代浏览器中将包含这五种**通用任务源**对应的**任务队列**，同时还有一个**微任务队列**。
浏览器如何处理这些“**队列**”，和**任务**，将会在接下来的章节叙述。

### JavaScript 执行上下文和执行上下文栈

我们在之前的章节也谈到了，任务声明了其要执行的**步骤**。这些步骤是算法的步骤。我们说运行任务，实际是一定规定执行任务的步骤。在步骤中，可能存在关联的回调，这些回调就需要传递一些参数，交给 JavaScript 引擎**执行**。

伴随而来的两个概念是[**执行上下文**](https://tc39.es/ecma262/#sec-execution-contexts)和[**执行上下文栈**](https://tc39.es/ecma262/#execution-context-stack)。我们可以在 [ECMA262](https://tc39.es/ecma262/#sec-execution-contexts) 中找到它们的定义—— 

**执行上下文**是一种规范设备，其被 ECMAScript 实现用以追踪代码的运行时求值。在任何时点上，每个[**代理**](https://tc39.es/ecma262/#agent)最多有一个实际运行代码的执行上下文。在 ECMA262 规范中，这被称为代理的**运行执行上下文**。

**执行上下文栈**是用于追踪执行上下文的堆栈。运行执行上下文总是栈顶元素。只要控制从当前运行执行上下文转移到与该执行上下文**无关**的可执行代码，就会创建一个新的执行上下文。新创建的执行上下文会推入栈中并成为运行执行上下文。

一个执行上下文无论实现如何都必须包含特定状态以追踪它所关联代码的执行状态。每个执行上下文至少有以下状态组件：
* 代码运行状态。任何当前需要用以执行、挂起或是恢复此执行上下文关联代码的状态。
* 函数。如果执行上下文对函数对象进行求值，这就是该函数对象。如果执行上下文是脚本或模块的求值，那么值为 null。
* [域（Realm）](https://tc39.es/ecma262/#realm)，相关代码访问 ECMAScript 资源的域记录。
* 脚本或模块。关联代码出处的模块记录或是脚本记录。如果没有出处脚本或模块，值为 null

我们可以大概地描述，当一个 JavaScript 引擎运行一段代码时，是在执行一个脚本或回调。在执行回调或脚本时，将往其执行上下文栈中压入一个执行上下文，此时，旧的运行执行上下文挂起，新的执行上下文成为运行执行上下文，在执行结束后恢复上一个执行上下文。

我们常称执行上下文栈为执行栈，或代码执行栈，但在深层次理解 JavaScript 的运行时必须清楚其存放的是何种数据类型。

### 事件循环处理模型

要想摸清事件循环到底如何工作的，还是需要对照 WHATWG 规范中的[处理模型](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)一章，理解整个事件循环核心的工作机制。文末对其进行了部分翻译（附带部分对照表以查阅），方便了解其中细节，内容较多，日后将单独整理为文档格式，感兴趣的话可以[前往阅读](#规范翻译)，本文不再赘述。

事件循环处理模型提取重点部分，可总结如下：

事件循环模型存在时，**执行如下步骤**：
1. 如果有包含可运行任务的任务队列，则按照自己实现的算法**选择其中一个队列**。此时不可能选择微任务队列，但可能有与微任务源关联的任务队列：
    1. 提取该队列的第一个**可运行任务**。此时任务可能是微任务。
    2. **运行任务**，运行完毕时，此时现象为执行上下文栈**空**。
    3. **执行微任务检查点**：
        1. 如果正在执行微任务检查点标志为 true，则返回。
        2. 设置正在执行微任务检查点标志为 true。
        3. 满足微任务队列**不为空**，则：
            1. 从微任务队列出队一个微任务，**执行微任务**。
        4. 设置正在执行微任务检查点标志为 false。此时微任务队列**清空**，执行上下文栈再次为**空**。
    4. 对于 window 事件循环，如果不再有包含可运行任务队列，计算允许执行的死线，然后执行开始空闲周期算法，将 `requestIdleCallback` 传入回调关联的任务排队到相关任务队列。
    5. 对于 worker 事件循环，运行其动画帧回调

并行地，window 事件循环必须执行以下步骤：
1. 等待一个事件循环关联的表示文档的“可通行”（特殊数据结构，Navigable）具有**渲染机会**，入队执行以下步骤的全局任务：
    1. 排序、筛选活动文档并显示。
    2. 刷新自动聚焦候选。
    3. 对于每个筛选后的文档，执行以下步骤：
        1. 运行揭示文档步骤。此步骤包含了跨文档视图切换，并于文档的关联全局对象上派发“pagereveal”事件。 
        2. 运行调整尺寸步骤。此步骤于 Window 对象和 VisualViewport 上**派发“resize”事件**。
        3. 运行滚动步骤。此步骤于 Document 上冒泡地，或是非 Document 上不冒泡地**派发“scroll”事件**。
        4. 运行求值媒体查询步骤并报告改变步骤。此步骤于 MediaQueryList 上派发“change”事件
        5. 更新动画并发送相应事件。内部又包含一个微任务检查点。此过程**改变动画帧**而不是建立新的动画帧。
        6. 运行全屏步骤。此步骤派发“fullscreen”系列事件。
        7. 如果 Canvas 上下文丢失，运行上下文丢失步骤。
        8. 运行**动画帧回调**，即 `requestAnimationFrame` 排队的回调：
            1. 拷贝保存动画帧回调的映射的键。
            2. 对于每个键，执行：
                1. 调用映射中该键保存的回调
                2. 删除映射中这个键对应的值
        9. 开始布局相关步骤：
            1. 重新计算样式并更新布局。
            2. 处理 Resize Observer 回调。
        10. 处理页面聚焦逻辑，通常派发“blur”和“focus”事件，可能也于此之前派发“change”（对 input 元素）。
        11. 执行待定的过渡操作（视图过渡）。此操作派发过渡相关事件。
        12. 处理 Intersection Observer 回调。
        13. 更新渲染或用户界面。
        14. 处理顶级层移除。顶级层是浏览器特定的图层，用以显示应处于其他所有图层之上的元素，如全屏视频、dialog 等。

即便进行了一些简化，但显较长，但这样更方便我们从整体上理解事件循环整个系统的模型，纠正一些过往或者以后将发生的错误认知。

### 任务和微任务的顺序

我们讨论整个事件循环系统中的回调时，大部分回调是通过附着于任务上的形式进行处理的。针对于这部分回调，我们在讨论任务顺序的同时，实际也是在讨论回调的顺序。

参考“事件循环处理模型”一节，假设浏览器充分实现了规范，我们可以得出以下事实：

浏览器代码执行时，执行上下文栈不为空。每次执行新的函数，将推入一个新的执行上下文。直到所有当前运行代码执行完毕，执行上下文栈表现为空，开始事件循环的下一步骤。此时对应执行“微任务检查点”。因此，我们也说清空执行栈时执行微任务。

从这个角度看，总会有一个任务先于微任务执行，但我们直觉地从当前代码审视时，总不自觉地忽略掉当前运行任务，因此会说，微任务总是快于“宏任务”。这并不会对实际使用造成多少影响，但需要理解，精确来讲应该是，运行任务时，微任务总是先于下一个其他类型的任务执行。

执行微任务检查点时，必须清空所有的微任务。这意味着，当微任务内部再次为微任务队列添加微任务时，新的微任务最终会在此次检查点中执行。这样，假设无限地在微任务中排队微任务，必定造成应用的阻塞。

与之不同，其他任务在一趟循环中，仅会选择其中的一个，之后的步骤仍然会正常执行。因此可能会因长任务造成卡顿，但不会造成应用的阻塞。一个经典的例子就是分别使用 `setTimeout` 和 `queueMicrotask` 嵌套调用自身。

### 两个特殊函数

此外，我们常用的还有两个排队回调的函数，`requestAnimationFrame` 和 `requestIdleCallback`。

`requestAnimationFrame` 回调的处理（运行动画帧回调）发生在特定的全局任务之中，这个任务囊括了更新动画、更新渲染、滚动事件分发等。`requestIdleCallback` 则是不借助任务处理回调，在当前任务处理完，微任务清空**后**，如果没有存在可运行的任务的任务队列，就会允许执行空闲回调，而且其回调可以选择规划到下一次满足对应条件时执行。

乍一看，可能会认为 `requestAnimationFrame` （的回调）总是会在 `requestIdleCallback` （的回调）之前。但这只是不在事件循环中插入新任务的结果。二者实际的发生顺序情况是非常复杂的，因为后者受其他所有任务队列是否存在可运行任务的影响，由于浏览器多线程的架构，任务排队可以发生在任何时刻。假设我们调用二者（简称 rAF 和 rIC）时，浏览器不再排队除了渲染关联的全局任务（我们暂称其渲染任务）外的所有一切任务，那么：
* 如果没有渲染任务排队，仅 rIC 回调发生，rAF 永远不会发生。常见于页面进入后台状态。
* 如果渲染任务在 rIC 回调的进入条件判断后排队，那么 rIC 回调永远在 rAF 回调前发生。
* 如果渲染任务在 rIC 回调的进入条件判断前排队，那么 rAF 回调永远在 rIC 回调前发生。

注意，调用 `requestAnimationFrame` 并不意味着立刻会有渲染任务排队。渲染任务排队仅发生在有渲染机会时，比如说，设备显示器刷新率为 60Hz，同时页面在前台可见，那么不计入性能考虑的帧率优化等，一般会以$1/60$秒，即约 16.67 毫秒的固定间隔发生渲染机会，此时排队渲染任务。实际运行时，事件循环各环节执行时间不是固定的，尽管渲染机会尽可能周期地发生，但渲染任务在我们所谈的判断条件前还是后入队仍然是**随机**的。

```js
function test(times = 1000, happens = [], happenGap = 10) {
  while(times--) {
    setTimeout(() => {
       requestIdleCallback(() => {
        happens.push('rIC');
      });
      requestAnimationFrame(() => {
        happens.push('rAF');
      });
    }, 50);
  }
}
const output = [];
test(100, output, 10);
console.log(output);
```

可以修改参数多尝试几次，二者发生的顺序是随着时间不断改变的。鉴于并行因素的存在，我们想确保二者回调之间存在执行顺序是**没有意义**的，使用 Web API 理应更关注其实际的功能描述。

与上一节的 `setTimeout` 和 `queueMicrotask` 类似，我们也来讨论一下回调中嵌套调用 `requestAnimationFrame` 或 `requestIdleCallback` 的情况。

[运行动画帧回调](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks)中指出，运行动画帧回调需要把目标动画帧回调的映射的键全部取出，然后根据取出的键，运行键对应的回调并进行移除。这意味着，即使在回调中使用 `requestAnimationFrame` 增加新的回调，也只会在下一个渲染机会到来时运行。也就是说，嵌套调用此函数不会导致阻塞。

[开始空闲期算法](https://w3c.github.io/requestidlecallback/#start-an-idle-period-algorithm)中指出，待定的空闲回调将被移动至可运行的空闲回调列表，然后在[调用空闲回调算法](https://w3c.github.io/requestidlecallback/#dfn-invoke-idle-callbacks-algorithm)中描述从该可运行空闲回调列表中取出回调并执行。这意味着，即使将所有空闲回调运行完，其中使用 `requestIdleCallback` 增加新的回调也是不会在此次步骤中执行的，可以理解为一种快照的机制。

### 事件监听器的回调

整理了事件循环处理模型相关的规范，一些关于事件监听的处理变得明朗起来。

我们关注渲染相关全局任务的部分，发现**运行动画帧回调将其步骤一分为二**。在运行动画帧回调前，运行了调整尺寸、求值媒体查询并报告变化、滚动、更新动画和全屏等步骤。在运行动画帧之后，运行了更新布局和样式计算、处理 Resize Observer 相关部分、处理聚焦逻辑、处理页面过渡、更新 Intersection Observer 相关内容、更新渲染和 UI、处理顶级层移除元素等步骤。相应地，步骤中进行对应事件的分发，如 resize、scroll、blur 等。运行事件分发同时会**同步地**将关联的回调取出并执行。这意味着，通常情况下，为这些事件添加的事件监听器将会和动画帧回调**几乎同样的频率**进行调用，并且会**按照规范中提及的顺序**调用。

当然，我们这里要提及一个反例。早些年的 Edge 实现，把运行动画帧回调放到了更新渲染之**后**，这也就导致了在使用 `requestAnimationFrame` 时总会慢半拍的情况。后面自然是修复了这个问题，不那么特立独行了。

不过，我们提及了几个 Observer 和更新动画，那么 Mutation Observer 和 transition 事件的处理在哪呢？对于前者，它并不是事件循环处理模型的一部分，通过其他模块将微任务排队到微任务队列。后者，则是包含在更新动画步骤中了。

而用户交互、网络事件等类型的监听器的回调——将会在满足条件后对任务/微任务进行排队。比方说，我们点击一个按钮，将会有一个任务入队到用户交互任务源相关联的任务队列中。在事件循环的较前的几个步骤中，任务最终被消费。两个常用的拥有回调功能的 API，XMLHttpRequest 和 fetch API，分别对应了任务和微任务（后者使用期约 Promise）。每趟事件循环由于任务队列选择，不总是处理网络任务，但一定会处理所有微任务，这样，当大量请求同时到来时，前者可能会穿插渲染和其他任务，后者可以尽可能在其他任务，如渲染任务前处理完所有请求的回调。

至此，关于事件循环大致已经说清，接下来我们按照已经明朗的细节，拓展地谈一谈相关的话题。

## 关于 DOM 修改的那些事

初学 DOM 编程的时候，我总会担心，如果我在执行完这个操作——

**会不会文档渲染立刻产生变化，多个操作会不会导致灾难性的影响？**

**AJAX 异步调用会不会产生竞态条件（Race Condition）？**

有时候，必须要反复确认测试才能安心一点……也只是一点。大学时期，身为菜鸟初学者的我和学长在做开发 Web 应用的兼职，总是遇到 JavaScript 奇奇怪怪的异步问题。于是，我们的独门秘招就是，出了问题 setTimeout，一个不行再来一个。可能有点搞笑，但确实是亲身经历。

读到现在，我们已经对 JavaScript 整体有了一些深度认识，现在已经可以解答这些问题了！

### 多次修改合为一次？

#### 多次 DOM 修改的结果如何呢？
首先来回答我们刚才提出的第一个问题。浏览器架构巧妙地将渲染作为某种任务的一部分融入到了基于事件驱动的系统中。因此，明确地说，除非触发强制同步布局，不然在一段代码中修改文档和元素样式，只会有渲染步骤前最终的结果会应用到屏幕上。从这个意义上来说，多次修改合为一次是非必要的。

#### 布局、布局颠簸和 DocumentFragment
那么多个 DOM 修改操作会不会导致灾难性的（性能）影响？如果有人告诉你，尽量避免多次修改 DOM，尽量整合为一个 DocumentFragment 再插入，因为直接修改 DOM 会触发页面布局……道理有点，但不多。

布局英文为 layout 或是 reflow，亦可称为重排。它是页面渲染流水线的一部分，指的是重新计算页面元素，确定各个元素的位置和尺寸，然后创建布局树。这是个昂贵的操作，因为需要遍历 DOM 和计算出的样式，尤其是在样式修改影响元素较多时尤为昂贵。通常会于布局前更新样式，其后执行绘制和合成。我们称在一段代码里交替地修改样式和触发强制布局导致页面反复密集地布局为布局颠簸，或是布局抖动。

修改样式直接触发布局仅限于使用[强制同步布局 API](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)，例如 offsetLeft 等。如果我们不注意 DOM API 的使用，经常触发布局颠簸，直接修改样式而不是借助 DocumentFragment 再插入，那么性能将会很差。除此之外，使用 DOM API 主要的损耗在于 JavaScript 与外部系统可能的上下文切换代价，但……使用 DocumentFragment 真的可以避免吗？

我们说 DocumentFragment 是轻量版的 Document，插入其内不会触发 DOM 树的更新。所以，把它插入 DOM 树也不会更新——才怪，那样看不见新增的节点了。有一种说法，使用 DocumentFragment 插入批量节点只会更新一次，分开批量插入节点会触发多次布局，甚至 MDN 的中文文档截止至目前，2024年7月，还是[这样](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E)描述的。嗯，太怪了，太怪了。我把 DocumentFragment 插入 DOM 树剩下一个空的该对象，还能像粘贴文本一样啊。看看[规范文档](https://dom.spec.whatwg.org/#concept-node-children-changed-ext)怎么说。插入 DocumentFragment 最终还是对于每个节点进行了插入操作。

用 DocumentFragment 插入批量节点看来是没有什么性能优化了，反而可能多出了一些步骤，部分引擎测试的性能甚至要比直接插入批量节点要慢一些，在英文版的 MDN 文档指出了[这一点](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment#performance)。在本人的[浏览器测试](https://jsbench.me/02l63eic9j/1)中，大概要比直接插入的版本慢9%。

<figure class='text-center'>
  <Picture src={imageBenchmarkTest} width={755} height={317} formats={['avif', 'webp']} alt='DocumentFragment 性能测试' class='mx-auto w-auto'  />
  <figcaption>DocumentFragment 性能测试</figcaption>
</figure>

使用 DocumentFragment，最主要的原因应当还是出于代码可读性和操作方便性的考虑，使用它进行优化能只是以讹传讹的说法罢了。顺带提一句，隐藏元素并在修改后再显示可能也不是个很好的做法，可能有点一叶障目，除非你是分批次多趟事件循环才完成修改（那也要考虑修改的是什么样式、修改多少）。

那么，果真多次 DOM 修改合为一次没有什么用了吗？嗯，我只能说，如果不涉及强制布局同步，其实差异不大，你可以自己进行一些测试。这个问题再深入探讨起来就像是对比两碗一百克的米饭一样，“不合并”总会少一两粒米。更重要的是逻辑看起来比较顺畅清爽，而且让非常重视合并 DOM 修改优化性能的人也能得到慰藉。但请记住，不要出于性能优化做这件事，也不要认为真的“性能优化”了。况且，过早的优化往往会拖慢你的效率。

### 虚拟 DOM 真的优化了 DOM 修改了吗？

讲到这里，我联想到另一个类似的场景。我在一些文章中见到一个常见的说法，虚拟 DOM 总是要比 DOM 快。或者是，在到达某个阈值后，虚拟 DOM 总是要比 DOM 快。这是不正确的。

一说在 React 之前，虚拟 DOM 尚未达到可用程度，Meta 公司团队改进了虚拟 DOM 算法使得其时间复杂度降低至可用，并用其作为声明式编程的支撑。这之后，总是会有人宣传虚拟 DOM 的“快”这一特点。

我们先限定以下说法，因为虚拟 DOM 总是要比 DOM 快实际比较的是“使用虚拟 DOM 调用 API 修改 DOM 总是要比直接调用 API 修改 DOM 要快”。至此，你应该发现了什么。

在常用的框架中的虚拟 DOM 算法，现代的 Vue3 选择的策略是每个节点对比后直接 patch 节点，而 React 19 则是借助 Fiber 架构简历副作用列表并在任务调度中批量更新。无论具体实现如何，归根到底，虚拟 DOM 还是需要进行真实的 DOM 操作，此外，它总是会在 DOM 上添加一层额外层，同时需要管理以对比新旧节点的区别，以合并和最小化修改。

我们假设 DOM 操作总是最优的且我们知道这种方法。在这个前提下，多一层额外层和管理需求，意味着额外的空间和时间消耗（更何况，虚拟 DOM 自身也需要传输 JavaScript 代码）。这样，总会是 DOM 直接操作更优。

至此，我们得出一个结论，最终得出同样 DOM 操作的情况下，虚拟 DOM 要**慢**。

但是，我们需要陈述一个事实，并不是所有人都知道最优的 DOM 操作方法，况且还可能无意间触发强制布局同步，实际不总是直接操作 DOM 更快。提供虚拟 DOM 类的框架主要优势在于声明式编写数据驱动的应用，对开发者友好，同时虚拟 DOM 替换 API 操作层可以用于构建其他环境的应用（但真实情况复杂的多），如 React Native，虽然这类应用性能总是较差的，胜在开发效率高（没踩坑或要求优化之前）。当今前端领域，也已经出现拥抱 No Virtual DOM 的声明式解决方案，如 Svelte，或是主要纯服务端构建 HTML 页面的声明式解决方案，如 Astro，以规避虚拟 DOM 性能上的问题。

总结而言，虚拟 DOM 确实优化了 DOM 修改，但通常不是性能方面的，而是关于开发者体验和效率方面的。

### 围绕 DOM 修改使用 `requestAnimationFrame`

了解了事件循环，`requestAnimationFrame` 的功能也在专注动画更新之外出现了新的奇淫技巧。

#### 延迟 DOM 修改

如果你的操作分布在许多不同的函数中，且它们其中的一些将修改共用的值，然后触发强制同步布局，但你需要的是当前帧状态的值，而不是更新后的，也许你不能保证各模块按顺序执行，或是缓存到全局要保持同步非常麻烦，就可以使用 `requestAnimationFrame` 延迟修改，使得。举个非真实世界的例子：

```js
const el = document.createElement('div');
el.style.cssText = `position: absolute; top: 0; left: 0; width: 20px; height: 20px; background: #000`;
// 在控制模块
function moveTop() {
  const top = el.getClientBoundingRect().top;
  requestAnimationFrame(() => {
    el.style.top = `${top + 10}px`;
  });
}
// 在
function recordTop() {
    const top = el.getClientBoundingRect().top;
    console.log(top);
}
```
#### 获取布局更新后的新样式

如果你前端经验丰富，一定遇到过需要触发布局更新后获取新布局的情况。如果你不是很情愿触发强制布局更新，导致每次都多那么一次布局和绘制的话，这里有一个方法，称之为二重动画帧回调：

```js
function runAfterDOMUpdate(fn) {
  function nextFrameWork() {
    requestAnimationFrame(fn);
  }

  requestAnimationFrame(nextFrameWork);
}
```

这个方法巧妙地运用了动画帧回调在浏览器事件循环中的位置。

### 异步调用会不会产生竞态条件？

结论而言，不会。你可以放心地修改 DOM，大胆去在异步中修改。

浏览器架构遵循了一个黄金法则，针对于 UI 修改的线程只能有一个，从而避免了大多异步带来的非预期问题。也就是说，无论异步进行了什么操作，它关联的回调永远是回到主线程中运行的——主线程做完手头的工作，才会轮到这些回调，不会出现竞态条件。同时，它对于 DOM/CSSOM 的修改不会同步地反映到屏幕上，除非触发强制同步布局，否则就是在下一个渲染机会到来时被同步到屏幕。最终我们需要考虑的是，如果多个异步同时进行，最终回调都修改 DOM，那么需要确保回调执行顺序吗？如何去确保？这就是另一个话题了。

## 再说防抖

防抖这个技术，旨在限制某算法以特定间隔发生。常见的一个用例就是针对于页面滚动加载的事件监听进行节流。

```js
import { throttle } from 'lodash';
const callback = throttle(() => {}, 50);
window.addEventListener('scroll', callback);
```

我们常用的防抖技术主要基于特定的标志遍历和计时器的应用，也有人提出一种基于 requestAnimationFrame 的防抖方案，此处也一并讨论。

防抖技术的用途意味着，如果防抖的间隔低于或等于事件的发生的间隔，那防抖将没有意义。

我们讨论过事件循环的处理模型，在其中看到了一些事件分发步骤作为渲染任务的一部分存在，比如“scroll”，而 requestAnimationFrame 在其后。

这意味着，其一，“scroll”事件将在具有渲染机会时触发，那么，理想状态下触发后会以屏幕刷新率的固定间隔在一定时间内连续发生。对于存世量仍不少的 60Hz 的显示器，这个间隔理想状态下是约 16.7ms，意味着，如果小于这个间隔，防抖将是无意义的。因此，最好在防抖前思考一下是大于了显示器刷新的间隔。

其二，“scroll”事件回调将与 requestAnimationFrame 以大致相同频率触发。因此，使用 requestAnimationFrame 进行“scroll”事件的节流是个非常有意思的选择，非常幽默。这个例子我也在 MDN 的[文档](https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event#scroll_event_throttling)中见到过，作为参考举例，虽然较委婉地声明了不该这样写，但谁知道呢，可能有人会不看说明呢？

















## 规范翻译

事件循环必须通过以下步骤持续运行，只要当其仍然存在：
1. 声明 <var>oldestTask</var> 和 <var>taskStartTime</var> 为 null。
2. 如果**事件循环**有至少有一个**可运行任务**的**任务队列**，那么：
    1. 声明 <var>taskQueue</var> 为所述任务队列之一，以[实现定义](https://infra.spec.whatwg.org/#implementation-defined)的风格进行选择。
    <aside>
    注意：记住，[微任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue)不是[任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue),因此它不会在此步骤中被选中。然而，与[微任务任务源](https://html.spec.whatwg.org/multipage/webappapis.html#microtask-task-source)相关联的[任务队列](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)。在此场景下，在后续骤中被选中的[任务](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)原本是[微任务](https://html.spec.whatwg.org/multipage/webappapis.html#microtask)，但作为[执行事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#spin-the-event-loop)的一部分被移动了。
    </aside>
    2. 赋值 <var>taskStartTime</var> 以不安全的共享的当前时间。
    3. 赋值 <var>oldestTask</var> 以 <var>taskQueue</var> 中第一个可运行任务，同时从 <var>taskQueue</var> 中移除。
    4. 如果 <var>oldestTask</var> 非 null，则给定 <var>taskStartTime</var> 和 <var>oldestTask</var> 以记录任务开始时间。
    5. 赋值[事件循环]的[当前运行任务]以 <var>oldestTask</var>。
    6. 执行 <var>oldestTask</var> 的步骤。
    7. 赋值[事件循环]的[当前运行任务]为 null，回到初始值。
    8. 执行一个微任务检查点。
3. 声明 <var>taskEndTime</var> 为不安全的共享的当前时间。[高精度时间]
4. 如果 <var>oldestTask</var> 非 null，则：
    1. 声明 <var>top-level browsing contexts</var> 为一个空集合。
    2. 对于 <var>oldestTask</var> 的脚本求值的环境设定对象集合中的每个环境设定对象 <var>settings</var>：
        1. 声明 <var>global</var> 为 <var>settings</var> 的全局对象。
        2. 如果 <var>global</var> 非 Window 对象，则继续。
        3. 如果 <var>global</var> 的[浏览上下文](https://html.spec.whatwg.org/multipage/nav-history-apis.html#window-bc)为 null，则继续。
        4. 声明 <var>tlbc</var> 为 <var>global</var> 的浏览上下文的[顶级浏览上下文](https://html.spec.whatwg.org/multipage/document-sequences.html#bc-tlbc)。
        5. 如果 <var>tlbc</var> 非 null，则将其添加到 <var>top-level browsing contexts</var>。
    3. [报告长任务](https://w3c.github.io/longtasks/#report-long-tasks)，传入 <var>taskStartTime</var>、<var>taskEndTime</var>、<var>top-level browsing contexts</var>、
    <var>oldestTask</var>。
    4. 如果 <var>oldestTask</var> 的 [document](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-document) 非 null，则给定 <var>taskEndTime</var> 和 <var>oldestTask</var> 以[记录任务结束时间](https://w3c.github.io/long-animation-frames/#record-task-end-time)。
5. 如果此事件循环是[window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop)，且其所有事件循环的任务队列中没有可运行任务，则：
    1. 赋值此事件循环的上个空闲周期开始时间以不安全的共享的当前时间。
    2. 声明 <var>computeDeadline</var> 为以下步骤：
        1. 声明 <var>deadline</var> 为此事件循环的上个空闲周期开始时间再加 50。
        注意：给定未来 50ms 的上限以确保在用户感知阈值内可以响应新的用户输入。
        2. 声明 <var>hasPendingRenders</var> 为 false。
        3. 对于此事件循环的[所有相同循环窗口](https://html.spec.whatwg.org/multipage/webappapis.html#same-loop-windows)中的每个 <var>windowInSameLoop</var>：
            1. 如果 <var>windowInSameLoop</var> 的[动画帧回调映射](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#list-of-animation-frame-callbacks)非空，或者，如果用户代理确信 <var>windowInSameLoop</var> 可能有阻塞的渲染更新，那么赋值 <var>hasPendingRenders</var> 为 true。
            2. 声明 <var>timerCallbackEstimates</var> 为 <var>windowInSameLoop</var> 的[活动计时器映射](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#map-of-active-timers)进行[获取全部值](https://infra.spec.whatwg.org/#map-getting-the-values)的结果。
            3. 对于 <var>timerCallbackEstimates</var> 中的每个 <var>timeoutDeadline</var>，如果 <var>timeoutDeadline</var> 小于 <var>deadline</var>，赋值 <var>deadline</var> 以 <var>timeoutDeadline</var>。
        4. 如果 <var>hasPendingRenders</var> 为 true，则：
            1. 声明 nextRenderDeadline 为此事件循环中[上个渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)加上（1000除以当前刷新率）。
               刷新率可以是硬件上的或是特定于实现的。对于 60Hz 的刷新率，<var>nextRenderDeadline</var> 可能是[上次渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)后约 16.67ms.
            2. 如果 <var>nextRenderDeadline</var> 小于 <var>deadline</var>，则返回 <var>nextRenderDeadline</var>。
        5. 返回 <var>deadline</var>。
    3. 对于此[事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop)[同循环窗口](https://html.spec.whatwg.org/multipage/webappapis.html#same-loop-windows) 的每个窗口 <var>win</var>，为 <var>win</var> 执行[开始空闲期算法](https://w3c.github.io/requestidlecallback/#start-an-idle-period-algorithm)，传递以下步骤（作为参数）：调用 <var>computeDeadline</var>，对于其结果，给定 <var>win</var> [相关设定对象](https://html.spec.whatwg.org/multipage/webappapis.html#relevant-settings-object)的[跨源隔离能力](https://html.spec.whatwg.org/multipage/webappapis.html#concept-settings-object-cross-origin-isolated-capability)以[粗化](https://w3c.github.io/hr-time/#dfn-coarsen-time)，这之后返回该值。[REQUESTIDLECALLBACK](https://html.spec.whatwg.org/multipage/references.html#refsREQUESTIDLECALLBACK)
6. 如果此循环是[worker 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#worker-event-loop-2)，则：
    1. 如果此事件循环[代理](https://tc39.es/ecma262/#sec-agents)的单一[域（Realm）](https://tc39.es/ecma262/#sec-code-realms)的[全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-realm-global)是一个[被支持的](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#concept-animationframeprovider-supported) [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope)，且用户代理坚信代理自身将从执行其此次渲染更新中受益，则：
        1. 声明 <var>now</var> 为给定 [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope) 的[当前高精度时间](https://w3c.github.io/hr-time/#dfn-current-high-resolution-time)。[高精度时间]
        2. 执行该 [DedicatedWorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope) 的所有动画帧回调，传入 <var>now</var> 作为时间戳。
        3. 更新该 Dedicated Worker 的渲染以反映当前的状态。
        注意：类似于在 [window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop)中[更新渲染](https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering)的注意事项（见上），用户代理可以决定 Dedicated Worker 渲染的速率。
    2. 如果该事件循环的所有任务队列都没有任务，且 [WorkerGlobalScope](https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope) 对象的[关闭](https://html.spec.whatwg.org/multipage/workers.html#dom-workerglobalscope-closing)标志为 true，则销毁事件循环，中止这些步骤，恢复后续 Web Worker 章节中描述的[运行 worker](https://html.spec.whatwg.org/multipage/workers.html#run-a-worker) 的步骤。

[window 事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#window-event-loop) <var>eventLoop</var> 也必须并行地运行下述步骤，只要当其仍然存在：
    1. 等待，直到至少有一个[“可通行”（特殊数据结构，这里作名词）](https://html.spec.whatwg.org/multipage/document-sequences.html#navigable) <var>navigable</var>，其[活动文档](https://html.spec.whatwg.org/multipage/document-sequences.html#nav-document)[相关代理](https://html.spec.whatwg.org/multipage/webappapis.html#relevant-agent)的事件循环是 <var>eventLoop</var>，且其可能具有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)。
    2. 赋值 <var>eventLoop</var> 的[上次渲染机会时间](https://html.spec.whatwg.org/multipage/webappapis.html#last-render-opportunity-time)为不安全的共享的当前时间。
    3. 对于每个具有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)的 <var>navigable</var>，给定 <var>navigable</var> 的[活动窗口](https://html.spec.whatwg.org/multipage/document-sequences.html#nav-window)[以入队一个全局任务](https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-global-task)，从而**更新渲染**。
    <aside>
    注意：这可能会导致出现重复调用以更新渲染。但是，因为它们作为必要渲染步骤，此时没有渲染的必要，所以这些调用不会造成可观测的影响。实现中可以引入进一步的优化，像是仅当此任务尚未入队时才将其入队。但是，要注意该任务在得到处理前，其关联的文档可能变为非活动状态。
    </aside>
        1. 声明 <var>frameTimestamp</var> 为 <var>eventLoop</var> 的上次渲染机会时间。
        2. 声明 <var>docs</var> 为所有[相关代理](https://html.spec.whatwg.org/multipage/webappapis.html#relevant-agent)的事件循环是 <var>eventLoop</var> 的[完全活动](https://html.spec.whatwg.org/multipage/document-sequences.html#fully-active) [文档对象](https://html.spec.whatwg.org/multipage/dom.html#document)，其任意排序但需要满足以下条件：
            * 任何[容器文档](https://html.spec.whatwg.org/multipage/document-sequences.html#doc-container-document)为 A 的[文档] B 在列表中必须排在 A 之后
            * 如果由两个文档 A 和 B，均有相同非 null [容器文档](https://html.spec.whatwg.org/multipage/document-sequences.html#doc-container-document) C，则 A 和 B 在列表中的顺序必须满足它们在 C 的[节点树](https://dom.spec.whatwg.org/#concept-node-tree)中对应[“可通行”容器](https://html.spec.whatwg.org/multipage/document-sequences.html#navigable-container)的[影子包含树顺序](https://dom.spec.whatwg.org/#concept-shadow-including-tree-order)。
        在下述迭代 <var>docs</var> 的步骤中，每个文档对象必须按照其在列表中发现的顺序被处理。
        3. 过滤不可渲染的文档：从 <var>docs</var> 中移除满足下列任意条件的所有文档对象 <var>doc</var>：
            * <var>doc</var> 是[渲染阻塞](https://html.spec.whatwg.org/multipage/dom.html#render-blocked)的；
            * <var>doc</var> 的[可见状态](https://html.spec.whatwg.org/multipage/interaction.html#visibility-state)为 “hidden”；
            * <var>doc</var> 的渲染[因视图转换被阻止](https://drafts.csswg.org/css-view-transitions/#document-rendering-suppression-for-view-transitions)；或
            * <var>doc</var> 的[节点“可通行”](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable)当前没有[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)。
        注意：在[以并行](https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel)步骤检查之外，我们还必须在这里检查[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)，因为一些共享相同[事件循环](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop)的文档可能不会同时具有渲染机会。
        4. 非必要渲染：从 <var>docs</var> 中移除满足下列所有条件的所有文档对象 <var>doc</var>：
            * 用户代理坚信更新 <var>doc</var> 节点“可通行”的渲染不会有任何可见的影响；同时
            * <var>doc</var> [动画帧回调映射](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#list-of-animation-frame-callbacks)为空。
        5. 从 <var>docs</var> 中移除由于其他理由，用户代理坚信其适合跳过更新渲染的所有文档对象 <var>doc</var>。
        注意：
        此步骤标明了过滤不可渲染的文档阻止用户代理在无法向用户呈现新内容时更新渲染。
        此步骤标明了非必要渲染阻止用户代理在没有新内容需要绘制时阻止更新渲染。
        此步骤使用户代理能够因其他理由阻止下列步骤运行，例如，为确保某些[任务](https://html.spec.whatwg.org/multipage/webappapis.html#concept-task)在彼此之后能够立刻执行，仅交叉[微任务检查点](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint)（且不交叉其他，如[动画帧回调](https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks)）。具体来说，用户代理可能希望合并计时器回调到一起，而不立刻渲染更新。
        6. 对于 <var>docs</var> 中的每个 <var>doc</var>，[揭示](https://html.spec.whatwg.org/multipage/browsing-the-web.html#reveal) <var>doc</var>。
        7. 对于 <var>docs</var> 中的每个 <var>doc</var>，如果其[节点“可通行”](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable)是一个[顶级的“可遍历”](https://html.spec.whatwg.org/multipage/document-sequences.html#top-level-traversable)（特殊的数据结构，原文中形作名），为其[刷新自动聚焦候选](https://html.spec.whatwg.org/multipage/interaction.html#flush-autofocus-candidates)。
        8. 对于 <var>docs</var> 中的每个 <var>doc</var>，运行[调整尺寸步骤](https://drafts.csswg.org/cssom-view/#document-run-the-resize-steps)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        9. 对于 <var>docs</var> 中的每个 <var>doc</var>，运行[滚动步骤](https://drafts.csswg.org/cssom-view/#document-run-the-scroll-steps)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        10. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [求值媒体查询并报告改变](https://drafts.csswg.org/cssom-view/#evaluate-media-queries-and-report-changes)。[CSSOMVIEW](https://html.spec.whatwg.org/multipage/references.html#refsCSSOMVIEW)
        11. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [更新动画并发送事件](https://drafts.csswg.org/web-animations-1/#update-animations-and-send-events)，给定 <var>frameTimestamp</var> 和 <var>doc</var> [相关全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-relevant-global)作为时间戳，以[传入相对高精度时间](relative high resolution time)。[WEBANIMATIONS](https://html.spec.whatwg.org/multipage/references.html#refsWEBANIMATIONS)
        12. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [运行全屏步骤](https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps)。
        13. 对于 <var>docs</var> 中的每个 <var>doc</var>，如果用户代理检测到与任一 [CanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#canvasrenderingcontext2d) 或 [OffscreenCanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#offscreencanvasrenderingcontext2d)—— <var>context</var> ——相关联的后备存储已经丢失，则用户代理必须为每个类似的 <var>context</var> 运行**上下文丢失步骤**：
            1. 声明 <var>canvas</var> 为 <var>context</var> 的 [canvas](https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-canvas) 属性，如果上下文是一个  [CanvasRenderingContext2D](https://html.spec.whatwg.org/multipage/canvas.html#canvasrenderingcontext2d)，否则，声明其为 [<var>context</var> 相关的](https://html.spec.whatwg.org/multipage/canvas.html#associated-offscreencanvas-object) OffscreenCanvas 对象。
            2. 赋值 <var>context</var> 的[上下文丢失](https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-context-lost)为 true。
            3. 给定 <var>context</var> 以[重置渲染上下文到其默认状态](https://html.spec.whatwg.org/multipage/canvas.html#reset-the-rendering-context-to-its-default-state)。
            4. 声明 <var>shouldRestore</var> 为于 <var>canvas</var> 上[发送](https://dom.spec.whatwg.org/#concept-event-fire)一个名为 [contextlost](https://html.spec.whatwg.org/multipage/indices.html#event-contextlost) 的事件的结果，该事件的 [cancelable](https://dom.spec.whatwg.org/#dom-event-cancelable) 属性被初始化为 true。
            5. 如果 <var>shouldRestore</var> 为 false，则中止这些步骤。
            6. 尝试通过使用 <var>context</var> 的属性创建后备存储并将它们与 <var>context</var> 相关联的方法，来恢复 <var>context</var>。如果此方法失败，则中止这些步骤。
            7. 赋值 <var>context</var> 的上下文丢失为 false。
            8. 于 <var>canvas</var> 上[发送](https://dom.spec.whatwg.org/#concept-event-fire)一个名为 [contextrestored](https://html.spec.whatwg.org/multipage/indices.html#event-contextrestored) 的事件。
        14. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [运行动画帧回调]，给定 <var>frameTimestamp</var> 和 <var>doc</var> [相关全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-relevant-global)作为时间戳，以[传入相对高精度时间](relative high resolution time)。
        15. 声明 <var>unsafeLayoutStartTime</var> 为不安全的共享的当前时间。
        16. 对于 <var>docs</var> 中的每个 <var>doc</var>：
            1. 声明 resizeObserverDepth 为 0
            2. 满足 true 时：
                1. 为 <var>doc</var> 重新计算样式和更新布局
                2. 声明 <var>hadInitialVisibleContentVisibilityDetermination</var> 为 false。
                3. 对于每个“content-visibility”值为[“auto”](https://drafts.csswg.org/css-contain/#propdef-content-visibility)的元素 <var>element</var>：
                    1. 声明 <var>checkForInitialDetermination</var> 为 true，如果 <var>element</var> 的[视口邻近度](https://drafts.csswg.org/css-contain/#proximity-to-the-viewport)待定，且其非[用户相关的](https://drafts.csswg.org/css-contain/#relevant-to-the-user)。否则，声明 <var>checkForInitialDetermination</var> 为 false。
                    2. 确定 <var>element</var> 的[视口邻近度](https://drafts.csswg.org/css-contain/#proximity-to-the-viewport)。
                    3. 如果 <var>checkForInitialDetermination</var> 为 true，且 <var>element</var> 此时是[用户相关的](https://drafts.csswg.org/css-contain/#relevant-to-the-user)，则赋值 <var>hadInitialVisibleContentVisibilityDetermination</var> 为 true。
                4. 如果 <var>hadInitialVisibleContentVisibilityDetermination</var> 为 true，则[继续](https://infra.spec.whatwg.org/#iteration-continue)。
                注意：此步骤的意图是为了进行初始视口邻近度确定，其会立即生效，然后在此循环中稍前的某一步骤里的，完成的样式和布局计算中反映出来。非初始的邻近度确定将在下一个[渲染机会](https://html.spec.whatwg.org/multipage/webappapis.html#rendering-opportunity)中生效。[CSSCONTAIN](https://html.spec.whatwg.org/multipage/references.html#refsCSSCONTAIN)
                5. 为 <var>doc</var> [按深度收集活动的调整尺寸观测](https://w3c.github.io/csswg-drafts/resize-observer-1/#gather-active-observations-h) <var>resizeObserverDepth</var>。
                6. 如果 <var>doc</var> [有活动的调整尺寸观测](https://w3c.github.io/csswg-drafts/resize-observer-1/#has-active-observations-h)：
                    1. 赋值 <var>resizeObserverDepth</var> 以给定 <var>doc</var> [广播活动的调整尺寸观测](https://w3c.github.io/csswg-drafts/resize-observer-1/#broadcast-resize-notifications-h)的结果。
                    2. [继续](https://infra.spec.whatwg.org/#iteration-continue)。
                7. 否则，中断
            3. 如果 <var>doc</var> [有跳过的调整尺寸观测]，则给定 <var>doc</var> [传递调整尺寸循环错误](https://w3c.github.io/csswg-drafts/resize-observer-1/#deliver-resize-error)
        17. 对于 <var>docs</var> 中的每个 <var>doc</var>，如果 <var>doc</var> 的[聚焦区域](https://html.spec.whatwg.org/multipage/interaction.html#focused-area-of-the-document)不是一个[可聚焦的区域](https://html.spec.whatwg.org/multipage/interaction.html#focusable-area)，则运行为 <var>doc</var> 的[视口](https://drafts.csswg.org/css2/#viewport) 运行[聚焦步骤](https://html.spec.whatwg.org/multipage/interaction.html#focusing-steps)，且赋值 <var>doc</var> [相关全局对象](https://html.spec.whatwg.org/multipage/webappapis.html#concept-relevant-global)[导航 API](https://html.spec.whatwg.org/multipage/nav-history-apis.html#window-navigation-api)的[导航进行期间焦点被改变]为 false。
        示例：比方说，这可能由于元素被添加了 [hidden](https://html.spec.whatwg.org/multipage/interaction.html#attr-hidden) 属性，导致其停止[被渲染](https://html.spec.whatwg.org/multipage/rendering.html#being-rendered)而发生。也可能在 [input](https://html.spec.whatwg.org/multipage/input.html#the-input-element) 元素被[禁用](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-disabled)时，在该元素上发生。
        18. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [执行待定的过渡操作](https://drafts.csswg.org/css-view-transitions/#perform-pending-transition-operations)。
        19. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> [运行更新相交观测步骤]，给定 <var>now</var> 和 <var>doc</var> [相关全局对象]作为时间戳，以传入[相对高精度时间]
        20. 对于 <var>docs</var> 中的每个 <var>doc</var>，给定不安全的样式和布局开始时间 <var>unsafeStyleAndLayoutStartTime</var>，从而为 <var>doc</var> [记录渲染时间]。
        21. 对于 <var>docs</var> 中的每个 <var>doc</var>，为 <var>doc</var> 标记绘制时间。
        22. 对于 <var>docs</var> 中的每个 <var>doc</var>，更新 <var>doc</var> 及其[节点对应“可通行”类型值](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable)的渲染和用户界面，以反映当前状态。
        23. 对于 <var>docs</var> 中的每个 <var>doc</var>，给定 <var>doc</var> 以[处理顶端层移除]。
“可通行”类型值具有一个渲染机会，如果用户代理当前能够将该值的内容呈现给用户。这考虑了硬件刷新率的限制和用户代理出于性能原因的节流，即使内容在视口之外，其内容也可以是可呈现的。
“可通行”类型值的渲染机会基于硬件限制和其他因素决定。硬件限制，如显示器的刷新率。其他因素，如页面性能，或是该“可通行”类型值的活动文档可见状态是否为“visible”。渲染机会通常会以恒定间隔发生。
注意：此规范并未强制要求任何特定的模型以选择渲染机会。但举例来说，如果浏览器尝试达到 60Hz 刷新率，则渲染机会最多每60分之一秒（约 16.7ms）出现一次。如果浏览器发现“可通行”类型值无法维持此速率，它可以降至更可维持的每秒30次渲染机会，而不是间接地掉帧。类似地，如果一个“可通行”类型值不可见，用户代理可以决定将对应页面降至更慢的每秒4个渲染机会，甚至更低。

当用户代理要执行微任务检查点时：
1. 如果该[事件循环]的[正在执行微任务检查点]为 true，则返回：
2. 赋值该[事件循环]的[正在执行微任务检查点]为 true。
3. 满足该[事件循环]非[空]时：
    1. 声明 <var>oldestMicrotask</var> 为从[事件循环]的[微任务队列]中[出队]的结果。
    2. 赋值该[事件循环]的[当前运行任务] <var>oldestMicrotask</var>
    3. 运行 <var>oldestMicrotask</var>
    <aside>
      注意：这可能涉及调用脚本化回调，此种回调最终会调用包含再次调用[执行微任务检查点]算法的[运行脚本后清理]的步骤。这就是我们使用[执行微任务检查点]标志避免重入的原因。
    </aside>
    4. 赋值该[事件循环]的[当前运行任务]以 null，回到初始值
4. 对于[负责的事件循环]为该[事件循环]的每个[环境设定对象]，于其上[通知将被拒绝的期约]。
5. [清理 Indexed Database 事务]。
6. 执行 [ClearKeptObjects](https://tc39.es/ecma262/#sec-clear-kept-objects)()。
<aside>
注意：当 [WeakRef.prototype.deref()] 返回一个对象时，该对象在下次调用 [ClearKeptObjects](https://tc39.es/ecma262/#sec-clear-kept-objects)() 前会保持存活，在这之后它才将被垃圾回收。
</aside>
7. 赋值该[事件循环]的[正在执行微任务检查点]为 false。
8. [为微任务检查点记录时间信息]。


当一个并行运行的算法要等待一个稳定状态时，用户代理必须入队一个微任务，然后停止执行（算法的执行将在微任务运行时恢复，正如下列步骤中所描述的那样），该微任务运行以下步骤：
1. 运行算法的同步部分。
2. 如果合适，并行地恢复算法的执行，如算法步骤中所述。
<aside>
注意：同步部分中的步骤标有⌛。
</aside>

表示执行事件循环直到满足某一条件 <var>gloal</var> 的算法步骤等同于替换为以下代码步骤：
1. 声明 <var>task</var> 为该事件循环的当前运行任务。
<aside>
注意：任务可以是微任务。
</aside>
2. 声明 <var>task source</var> 为任务的源。
3. 声明 <var>old stack</var> 为[JavaScript 执行上下文栈]的副本。
4. 清空 [JavaScript 执行上下文栈]。
5. 执行微任务检查点。
<aside>
注意：如果 <var>task</var> 是此步骤中的微任务，由于[正在执行微任务检查点]为 true，此步骤会是一个 no-op（指此步无操作）。
</aside>
6. 并行：
    1. 等待，直到条件 <var>goal</var> 满足。
    2. 在任务源上入队任务，以便：
        1. 替换 JavaScript 执行上下文栈为 <var>oldTask</var>。
        2. 执行原始算法中，该执行事件循环实例后的任何步骤。
7. 停止 <var>task</var>，允许任何调用它的算法恢复。
<aside>
注意：这会导致该事件循环的主要步骤集或执行微任务检查点算法继续。
</aside>
<aside>
注意：与此规范及其他规范中的其他算法不同，其他算法的行为类似于编程语言的函数调用，而执行事件循环更类似于一个宏，它通过扩展为一系列的步骤和操作来减少使用处的打字和缩进。
</aside>

<table class='text-left'>
  <caption>部分翻译对照表</caption>
  <thead>
    <th>原文</th>
    <th>翻译</th>
    <th>备注</th>
  </thead>
  <tbody>
  <tr>
    <td>let ... be</td>
    <td>声明……为</td>
    <td>声明……并赋值</td>
  </tr>
  <tr>
    <td>set ... to</td>
    <td>赋值……以</td>
  </tr>
  <tr>
    <td>if ... then</td>
    <td>如果……则</td>
  </tr>
  <tr>
    <td>is ...</td>
    <td>为...</td>
  </tr>
  <tr>
    <td>is <var>variable</var></td>
    <td>是 <var>variable</var></td>
    <td>等效于浅比较上相等，是同一值</td>
  </tr>
  <tr>
    <td>is not...</td>
    <td>非...</td>
    <td></td>
  </tr>
  <tr>
    <td>for B of A</td>
    <td>对于 B 中的每个 A</td>
    <td>对 A 进行迭代，每趟迭代的元素以 B 表示</td>
  </tr>
  <tr>
    <td>while conditions</td>
    <td>满足某条件时</td>
    <td>循环语句</td>
  </tr>
   <tr>
    <td>do sth. given ...</td>
    <td>给定……以（从而）做某事</td>
    <td>给定参数执行算法</td>
  </tr>
  <tr>
    <td>perform ...</td>
    <td>执行……</td>
    <td></td>
  </tr>
  <tr>
    <td>excute ...</td>
    <td>执行……</td>
    <td></td>
  </tr>
  <tr>
    <td>resume</td>
    <td>恢复</td>
    <td></td>
  </tr>
  <tr>
    <td>continue</td>
    <td>继续</td>
    <td>进行算法步骤中循环的下一趟迭代</td>
  </tr>
  <tr>
    <td>break</td>
    <td>中断</td>
    <td>跳出当前循环</td>
  </tr>
  <tr>
    <td>otherwise</td>
    <td>否则</td>
    <td></td>
  </tr>
  <tr>
    <td>current</td>
    <td>当前</td>
    <td></td>
  </tr>
  <tr>
    <td>destroy</td>
    <td>销毁</td>
    <td></td>
  </tr>
  <tr>
    <td>abort</td>
    <td>中止</td>
    <td></td>
  </tr>
  <tr>
    <td>skipped</td>
    <td>跳过的</td>
    <td></td>
  </tr>
  <tr>
    <td>detect</td>
    <td>检测到</td>
    <td></td>
  </tr>
  <tr>
    <td>disabled</td>
    <td>禁用</td>
    <td></td>
  </tr>
  <tr>
    <td>this/that/the</td>
    <td>此/该</td>
    <td></td>
  </tr>
  <tr>
    <td>invoke</td>
    <td>调用</td>
    <td>指调用系统外事物，中文可概括</td>
  </tr>
  <tr>
    <td>call</td>
    <td>调用</td>
    <td></td>
  </tr>
  <tr>
    <td>spin the event loop</td>
    <td>执行事件循环</td>
    <td>spin 原指高速旋转，计算机科学中指代循环或迭代的执行过程</td>
  </tr>
  <tr>
    <td>environment settings object</td>
    <td>环境设置对象</td>
    <td></td>
  </tr>
  <tr>
    <td>script evaluation</td>
    <td>脚本求值</td>
    <td></td>
  </tr>
  <tr>
    <td>append</td>
    <td>添加</td>
    <td></td>
  </tr>
  <tr>
    <td>set</td>
    <td>集合</td>
    <td></td>
  </tr>
  <tr>
    <td>map</td>
    <td>映射</td>
    <td></td>
  </tr>
  <tr>
    <td>list</td>
    <td>列表</td>
    <td></td>
  </tr>
  <tr>
    <td>resize</td>
    <td>调整尺寸</td>
    <td></td>
  </tr>
  <tr>
    <td>scroll</td>
    <td>滚动</td>
    <td></td>
  </tr>
  <tr>
    <td>animation frame callback(s)</td>
    <td>动画帧回调</td>
    <td></td>
  </tr>
  <tr>
    <td>timer callback(s)</td>
    <td>计时器回调</td>
    <td></td>
  </tr>
  <tr>
    <td>pending</td>
    <td>待定</td>
    <td></td>
  </tr>
  <tr>
    <td>suspend</td>
    <td>挂起</td>
    <td></td>
  </tr>
  <tr>
    <td>block</td>
    <td>阻塞</td>
    <td></td>
  </tr>
  <tr>
    <td>active</td>
    <td>活动</td>
    <td>活动有活跃之意，由惯例使用前者</td>
  </tr>
  <tr>
    <td>microtask checkpoint(s)</td>
    <td>微任务检查点</td>
    <td></td>
  </tr>
  <tr>
    <td>map of animation frame callbacks</td>
    <td>动画帧回调映射</td>
    <td></td>
  </tr>
    <tr>
    <td>active window</td>
    <td>活动窗口</td>
    <td>活动</td>
  </tr>
  <tr>
    <td>map of active timers</td>
    <td>活动计时器映射</td>
    <td></td>
  </tr>
  <tr>
    <td>update the rendering</td>
    <td>更新渲染</td>
    <td></td>
  </tr>
  <tr>
    <td>last render opportunity time</td>
    <td>上个渲染机会</td>
    <td></td>
  </tr>
  <tr>
    <td>... document</td>
    <td>……文档</td>
    <td>属于某数据结构的文档，<br/>文中代指 Document 或 null</td>
  </tr>
   <tr>
    <td>Document (object)</td>
    <td>文档(对象)</td>
    <td>均代指某一类特殊数据结构</td>
  </tr>
  <tr>
    <td>navigable</td>
    <td>“可通行”类型（的值）</td>
    <td>navigable 形作名，类型就叫做“可通行”</td>
  </tr>
  <tr>
    <td>node navigable</td>
    <td>节点对应“可通行”类型值</td>
    <td></td>
  </tr>
  <tr>
    <td>navigable container</td>
    <td>“可通行”类型值的容器</td>
    <td></td>
  </tr>
  <tr>
    <td>top-level traversable</td>
    <td>顶级的“可遍历”</td>
    <td>指一类数据结构，形容词作名词</td>
  </tr>
  <tr>
    <td>shadow-including tree order</td>
    <td>影子包含树顺序</td>
    <td></td>
  </tr>
  <tr>
    <td>render-blocked</td>
    <td>渲染阻塞的</td>
    <td></td>
  </tr>
  <tr>
    <td>visibility state</td>
    <td>可见状态</td>
    <td></td>
  </tr>
  <tr>
    <td>view transition(s)</td>
    <td>视图转换</td>
    <td></td>
  </tr>
  <tr>
    <td>the backing storage</td>
    <td>后备存储</td>
    <td></td>
  </tr>
  <tr>
    <td>context</td>
    <td>上下文</td>
    <td></td>
  </tr>
  <tr>
    <td>attribute</td>
    <td>属性</td>
    <td></td>
  </tr>
  <tr>
    <td>restore</td>
    <td>恢复</td>
    <td></td>
  </tr>
  <tr>
    <td>recalculate styles and update layout</td>
    <td>重新计算样式和更新布局</td>
    <td>即重绘和重排，(re)paint 和 layout/(re)flow</td>
  </tr>
  <tr>
    <td>proximity to the viewport</td>
    <td>视口邻近度</td>
    <td>原文此时元素可近或远，故译邻近度</td>
  </tr>
  <tr>
    <td>determine</td>
    <td>确定</td>
    <td></td>
  </tr>
  <tr>
    <td>be not determined</td>
    <td>待定</td>
    <td></td>
  </tr>
  <tr>
    <td>is not determined</td>
    <td>待定</td>
    <td></td>
  </tr>
  <tr>
    <td>be relevant to the user</td>
    <td>用户相关的</td>
    <td></td>
  </tr>
    <tr>
    <td>resize observer</td>
    <td>调整尺寸观察者</td>
    <td></td>
  </tr>
  <tr>
    <td>resize observation</td>
    <td>调整尺寸观测</td>
    <td></td>
  </tr>
  <tr>
    <td>top layer</td>
    <td>顶端层</td>
    <td>特殊名词，故据上下文作区分，顶（端）</td>
  </tr>
  <tr>
    <td>rate</td>
    <td>速率</td>
    <td></td>
  </tr>
  <tr>
    <td>frame rate</td>
    <td>帧率</td>
    <td></td>
  </tr>
  <tr>
    <td>drop frame</td>
    <td>丢帧</td>
    <td></td>
  </tr>
  <tr>
    <td>rejected</td>
    <td>拒绝</td>
    <td></td>
  </tr>
  <tr>
    <td>promise</td>
    <td>期约</td>
    <td></td>
  </tr>
  <tr>
    <td>notify</td>
    <td>通知</td>
    <td></td>
  </tr>
  <tr>
    <td>about rejected promise</td>
    <td>将被拒绝的期约</td>
    <td>特殊名词，原文省略了介词以简写</td>
  </tr>
  </tbody>
</table>

## 事件循环？何时来的？


## 揭露真实的事件循环


## 其他环境中的事件循环


## 事件驱动和状态驱动

## 碎碎念

## 参考文献
[1]: WHATWG. HTML Living Standard[DB/OL]. [参考链接](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops). 2024-07-02
